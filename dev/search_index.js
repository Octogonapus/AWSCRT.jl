var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AWSCRT","category":"page"},{"location":"#AWSCRT","page":"Home","title":"AWSCRT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AWSCRT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AWSCRT]","category":"page"},{"location":"#AWSCRT.AWSCRT","page":"Home","title":"AWSCRT.AWSCRT","text":"Environment variables:\n\nAWS_CRT_MEMORY_TRACING: Set to 0, 1, or 2 to enable memory tracing. Default is off. See aws_mem_trace_level.\nAWS_CRT_MEMORY_TRACING_FRAMES_PER_STACK: Set the number of frames per stack for memory tracing. Default is the AWS library's default.\nAWS_CRT_LOG_LEVEL: Set to 0 through 6 to enable logging. Default is off. See aws_log_level.\nAWS_CRT_LOG_PATH: Set to the log file path. Must be set if AWS_CRT_LOG_LEVEL is set.\n\nNote: all the symbols in this package that begin with underscores are private and are not part of this package's published interface. Please don't use them.\n\n\n\n\n\n","category":"module"},{"location":"#AWSCRT.ClientBootstrap","page":"Home","title":"AWSCRT.ClientBootstrap","text":"mutable struct ClientBootstrap\n    ptr::Ptr{aws_client_bootstrap}\nend\n\nHandles creation and setup of client socket connections.\n\nNote on advanced use: the internal constructor on this struct has been left at its default so that you can bring your own native data if you need to. However, you are then responsible for the memory management of that data.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ClientBootstrap-Tuple{EventLoopGroup, HostResolver}","page":"Home","title":"AWSCRT.ClientBootstrap","text":"ClientBootstrap(el_group::EventLoopGroup, host_resolver::HostResolver)\n\nHandles creation and setup of client socket connections.\n\nArguments:\n\nel_group (EventLoopGroup): EventLoopGroup to use.\nhost_resolver (HostResolver): DNS host resolver to use.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.ClientTLSContext","page":"Home","title":"AWSCRT.ClientTLSContext","text":"mutable struct ClientTLSContext\n    ptr::Ptr{aws_tls_ctx}\nend\n\nClient TLS context. A context is expensive, but can be used for the lifetime of the application by all outgoing connections that wish to use the same TLS configuration.\n\nNote on advanced use: the internal constructor on this struct has been left at its default so that you can bring your own native data if you need to. However, you are then responsible for the memory management of that data.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ClientTLSContext-Tuple{AWSCRT.TLSContextOptions}","page":"Home","title":"AWSCRT.ClientTLSContext","text":"ClientTLSContext(options::TLSContextOptions)\n\nClient TLS context. A context is expensive, but can be used for the lifetime of the application by all outgoing connections that wish to use the same TLS configuration.\n\nArguments:\n\noptions (TLSContextOptions): Configuration options.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.EventLoopGroup","page":"Home","title":"AWSCRT.EventLoopGroup","text":"EventLoopGroup(num_threads::Union{Int,Nothing} = nothing, cpu_group::Union{Int,Nothing} = nothing)\n\nA collection of event-loops. An event-loop is a thread for doing async work, such as I/O.\n\nArguments:\n\nnum_threads (Union{Int,Nothing}) (default=nothing): Maximum number of event-loops to create. If unspecified, one is created for each processor on the machine.\ncpu_group (Union{Int,Nothing}) (default=nothing): Optional processor group to which all threads will be pinned. Useful for systems with non-uniform memory access (NUMA) nodes. If specified, the number of threads will be capped at the number of processors in the group.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.EventLoopGroup-2","page":"Home","title":"AWSCRT.EventLoopGroup","text":"mutable struct EventLoopGroup\n    ptr::Ptr{aws_event_loop_group}\nend\n\nA collection of event-loops. An event-loop is a thread for doing async work, such as I/O.\n\nNote on advanced use: the internal constructor on this struct has been left at its default so that you can bring your own native data if you need to. However, you are then responsible for the memory management of that data.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.HostResolver","page":"Home","title":"AWSCRT.HostResolver","text":"HostResolver(el_group::EventLoopGroup, max_hosts::Int = 16)\n\nDefault DNS host resolver.\n\nArguments:\n\nel_group (EventLoopGroup): EventLoopGroup to use.\nmax_hosts (Int) (default=16): Max host names to cache.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.HostResolver-2","page":"Home","title":"AWSCRT.HostResolver","text":"mutable struct HostResolver\n    ptr::Ptr{aws_host_resolver}\nend\n\nDefault DNS host resolver.\n\nNote on advanced use: the internal constructor on this struct has been left at its default so that you can bring your own native data if you need to. However, you are then responsible for the memory management of that data.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.MQTTClient","page":"Home","title":"AWSCRT.MQTTClient","text":"MQTTClient(\n    tls_ctx::Union{ClientTLSContext,Nothing},\n    bootstrap::ClientBootstrap = get_or_create_default_client_bootstrap(),\n)\n\nMQTT client.\n\nArguments:\n\ntls_ctx (Union{ClientTLSContext,Nothing}): TLS context for secure socket connections. If nothing, an unencrypted connection is used.\nbootstrap (ClientBootstrap) (default=get_or_create_default_client_bootstrap()): Client bootstrap to use when initiating new socket connections. Uses the singleton by default.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.MQTTConnection","page":"Home","title":"AWSCRT.MQTTConnection","text":"MQTTConnection(client::MQTTClient)\n\nMQTT client connection.\n\nArguments:\n\nclient ([MQTTClient](@ref)): MQTT client to spawn connection from.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.OnConnectionInterrupted","page":"Home","title":"AWSCRT.OnConnectionInterrupted","text":"on_connection_interrupted(\n    connection::MQTTConnection,\n    error_code::Int,\n)\n\nA callback invoked whenever the MQTT connection is lost. The MQTT client will automatically attempt to reconnect.\n\nArguments:\n\nconnection (MQTTConnection): The connection.\nerror_code (Int): Error which caused connection loss.\n\nnote: Note\nAll callbacks are run concurrently. Your callback implementations must be thread-safe. There is no concurrency limit.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.OnConnectionResumed","page":"Home","title":"AWSCRT.OnConnectionResumed","text":"on_connection_resumed(\n    connection::MQTTConnection,\n    return_code::aws_mqtt_connect_return_code,\n    session_present::Bool,\n)\n\nA callback invoked whenever the MQTT connection is automatically resumed.\n\nArguments:\n\nconnection (MQTTConnection): The connection.\nreturn_code (aws_mqtt_connect_return_code): Connect return code received from the server.\nsession_present (Bool): true if resuming existing session. false if new session. Note that the server has forgotten all previous subscriptions if this is false. Subscriptions can be re-established via resubscribe_existing_topics.\n\nnote: Note\nAll callbacks are run concurrently. Your callback implementations must be thread-safe. There is no concurrency limit.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.OnMessage","page":"Home","title":"AWSCRT.OnMessage","text":"on_message(\n    topic::String,\n    payload::String,\n    dup::Bool,\n    qos::aws_mqtt_qos,\n    retain::Bool,\n)\n\nA callback invoked when a message is received.\n\nArguments:\n\ntopic (String): Topic receiving message.\npayload (String): Payload of message.\ndup (Bool): DUP flag. If True, this might be re-delivery of an earlier attempt to send the message.\nqos (aws_mqtt_qos): Maximum requested QoS that the server may use when sending messages to the client. The server may grant a lower QoS in the SUBACK (see returned task).\nretain (Bool): Retain flag. If true, the message was sent as a result of a new subscription being made by the client.\n\nReturns nothing.\n\nnote: Note\nAll callbacks are run concurrently. Your callback implementations must be thread-safe. There is no concurrency limit.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.OnShadowMessage","page":"Home","title":"AWSCRT.OnShadowMessage","text":"on_shadow_message(\n    shadow_client::ShadowClient,\n    topic::String,\n    payload::String,\n    dup::Bool,\n    qos::aws_mqtt_qos,\n    retain::Bool,\n)\n\nA callback invoked when a shadow document message is received.\n\nArguments:\n\nshadow_client (ShadowClient): Shadow client that received the message.\ntopic (String): Topic receiving message.\npayload (String): Payload of message.\ndup (Bool): DUP flag. If true, this might be re-delivery of an earlier attempt to send the message.\nqos (aws_mqtt_qos): Maximum requested QoS that the server may use when sending messages to the client. The server may grant a lower QoS in the SUBACK (see returned task).\nretain (Bool): Retain flag. If true, the message was sent as a result of a new subscription being made by the client.\n\nReturns nothing.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ShadowClient","page":"Home","title":"AWSCRT.ShadowClient","text":"ShadowClient(\n    connection::MQTTConnection,\n)\n\nDevice Shadow service client. AWS Documentation.\n\nArguments:\n\nconnection (MQTTConnection): MQTT connection to publish and subscribe on.\nthing_name (String): Name of the Thing in AWS IoT under which the shadow document will exist.\nshadow_name (Union{String,Nothing}): Shadow name for a named shadow document or nothing for an unnamed shadow document.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ShadowDocumentPostUpdateCallback","page":"Home","title":"AWSCRT.ShadowDocumentPostUpdateCallback","text":"shadow_document_post_update_callback(shadow_document::AbstractDict)\n\nA callback invoked after the shadow document is updated. The parent ShadowFramework will not be locked when this callback is invoked. This is a good place to persist the shadow document to disk.\n\nArguments:\n\nshadow_document (AbstractDict): The updated shadow document.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ShadowDocumentPreUpdateCallback","page":"Home","title":"AWSCRT.ShadowDocumentPreUpdateCallback","text":"shadow_document_pre_update_callback(state::Dict{String,Any})\n\nA callback invoked before the shadow document is updated. The parent ShadowFramework will not be locked when this callback is invoked.\n\nArguments:\n\nstate (Dict{String,Any}): The incoming shadow state. This could be reported state or delta state.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ShadowDocumentPropertyPreUpdateFunction","page":"Home","title":"AWSCRT.ShadowDocumentPropertyPreUpdateFunction","text":"shadow_document_property_pre_update_function(shadow_document::AbstractDict, key::String, value)::Bool\n\nA function invoked when updating a property in the shadow document. This allows you to replace the update behavior in this package if you want to implement custom update behavior for a given property. The parent ShadowFramework will be locked when this function is invoked. The lock is reentrant.\n\n!!! warning \"Warning\"\n    This function may only update the given `key`. This function cannot modify other properties in the `shadow_document`.\n\nArguments:\n\nshadow_document (AbstractDict): The shadow document being updated.\nkey (String): The key in the shadow_document for the value being updated.\nvalue (Any): The new value for the key.\n\nReturns a Bool indicating whether an update was done.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ShadowDocumentPropertyUpdateCallback","page":"Home","title":"AWSCRT.ShadowDocumentPropertyUpdateCallback","text":"shadow_document_property_update_callback(value)\n\nA callback invoked immediately after a property in the shadow document is updated. The parent ShadowFramework will be locked when this callback is invoked. The lock is reentrant.\n\nArguments:\n\nvalue (Any): The new value of the property in the shadow document.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.ShadowFramework-Tuple{MQTTConnection, String, Union{Nothing, String}, AbstractDict}","page":"Home","title":"AWSCRT.ShadowFramework","text":"ShadowFramework(\n    connection::MQTTConnection,\n    thing_name::String,\n    shadow_name::Union{String,Nothing},\n    shadow_document::T;\n    shadow_document_property_callbacks::Dict{String,ShadowDocumentPropertyUpdateCallback} = Dict{\n        String,\n        ShadowDocumentPropertyUpdateCallback,\n    }(),\n    shadow_document_pre_update_callback::ShadowDocumentPreUpdateCallback = (v) -> nothing,\n    shadow_document_post_update_callback::ShadowDocumentPostUpdateCallback = (v) -> nothing,\n    id = 1,\n) where {T}\n\nCreates a ShadowFramework.\n\nArguments:\n\nconnection (MQTTConnection): The connection.\nthing_name (String): Name of the Thing in AWS IoT under which the shadow document will exist.\nshadow_name (Union{String,Nothing}): Shadow name for a named shadow document or nothing for an unnamed shadow document.\nshadow_document (AbstractDict): The local shadow document. This must include all keys in the shadow documents published by the broker. This must also include a version (Int) key which will store the shadow document version. It is recommended that you persist this to disk. You can write the latest state to disk inside shadow_document_post_update_callback. You should also then load it from disk and pass it as this parameter during the start of your application.\nshadow_document_property_callbacks (Dict{String,ShadowDocumentPropertyUpdateCallback}): An optional set of callbacks. A given callback will be fired for each update to the shadow document property matching the given key. Note that the callback is fired only when shadow properties are changed. A shadow property change occurs when the value of the shadow property is changed to a new value which is not equal to the prior value. This is implemented using !isequal(). Please ensure a satisfactory definition (satisfactory to your application's needs) of isequal for all types used in the shadow document. You will only need to worry about this if you are using custom JSON deserialization.\nshadow_document_pre_update_callback (ShadowDocumentPreUpdateCallback): An optional callback which will be fired immediately before updating any shadow document properties. This is always fired, even if no shadow properties will be changed.\nshadow_document_post_update_callback (ShadowDocumentPostUpdateCallback): An optional callback which will be fired immediately after updating any shadow document properties. This is fired only if shadow properties were changed.\nshadow_document_property_pre_update_funcs (Dict{String,ShadowDocumentPropertyPreUpdateFunction}): An optional set of functions which customize the update behavior of certain shadow document properties. See ShadowDocumentPropertyPreUpdateFunction for more information.\nid (Int): A unique ID which disambiguates log messages from multiple shadow frameworks.\n\nSee also ShadowDocumentPropertyUpdateCallback, ShadowDocumentPreUpdateCallback, ShadowDocumentPostUpdateCallback, MQTTConnection.\n\n!!! note \"Limitations\"\n    Removing properties by setting their desired value to `null` is not currently supported. AWS IoT will remove\n    that `null` property from the desired state, but the property will remain in the reported state.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.TLSConnectionOptions","page":"Home","title":"AWSCRT.TLSConnectionOptions","text":"mutable struct TLSConnectionOptions\n    ptr::Ref{aws_tls_connection_options}\nend\n\nConnection-specific TLS options. Note that while a TLS context is an expensive object, this object is cheap.\n\nNote on advanced use: the internal constructor on this struct has been left at its default so that you can bring your own native data if you need to. However, you are then responsible for the memory management of that data.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.TLSConnectionOptions-2","page":"Home","title":"AWSCRT.TLSConnectionOptions","text":"TLSConnectionOptions(\n    client_tls_context::ClientTLSContext,\n    alpn_list::Union{Vector{String},Nothing} = nothing,\n    server_name::Union{String,Nothing} = nothing,\n)\n\nConnection-specific TLS options. Note that while a TLS context is an expensive object, this object is cheap.\n\nArguments:\n\nclient_tls_context (ClientTLSContext): TLS context. A context can be shared by many connections.\nalpn_list (Union{Vector{String},Nothing}) (default=nothing): Connection-specific Application Layer Protocol Negotiation (ALPN) list. This overrides any ALPN list on the TLS context in the client this connection was made with. ALPN is not supported on all systems, see aws_tls_is_alpn_available.\nserver_name (Union{String,Nothing}) (default=nothing): Name for TLS Server Name Indication (SNI). Also used for x.509 validation.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.TLSContextOptions","page":"Home","title":"AWSCRT.TLSContextOptions","text":"TLSContextOptions(;\n    min_tls_version::aws_tls_versions = AWS_IO_TLS_VER_SYS_DEFAULTS,\n    ca_dirpath::Union{String,Nothing} = nothing,\n    ca_filepath::Union{String,Nothing} = nothing,\n    ca_data::Union{String,Nothing} = nothing,\n    alpn_list::Union{Vector{String},Nothing} = nothing,\n    cert_data::Union{String,Nothing} = nothing,\n    pk_data::Union{String,Nothing} = nothing,\n    verify_peer::Bool = true,\n)\n\nOptions to create a TLS context.\n\nArguments:\n\nmin_tls_version (aws_tls_versions) (default=AWS_IO_TLS_VER_SYS_DEFAULTS): Minimum TLS version to use. System defaults are used by default.\nca_dirpath (Union{String,Nothing}) (default=nothing): Path to directory containing trusted certificates, which will overrides the default trust store. Only supported on Unix.\nca_filepath (Union{String,Nothing}) (default=nothing): Path to file containing PEM armored chain of trusted CA certificates.\nca_data (Union{String,Nothing}) (default=nothing): PEM armored chain of trusted CA certificates.\nalpn_list (Union{Vector{String},Nothing}) (default=nothing): If set, names to use in Application Layer Protocol Negotiation (ALPN). ALPN is not supported on all systems, see aws_tls_is_alpn_available. This can be customized per connection; see TLSConnectionOptions.\ncert_data (Union{String,Nothing}) (default=nothing): Certificate contents. Treated as PKCS #7 PEM armored.\npk_data (Union{String,Nothing}) (default=nothing): Private key contents. Treated as PKCS #7 PEM armored.\nverify_peer (Bool) (default=true): Whether to validate the peer's x.509 certificate.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT.Will","page":"Home","title":"AWSCRT.Will","text":"Will(\n    topic::String,\n    qos::aws_mqtt_qos,\n    payload::String,\n    retain::Bool,\n)\n\nA Will message is published by the server if a client is lost unexpectedly.\n\nThe Will message is stored on the server when a client connects. It is published if the client connection is lost without the server receiving a DISCONNECT packet.\n\n[MQTT-3.1.2-8]\n\nArguments:\n\ntopic (String): Topic to publish Will message on.\nqos (aws_mqtt_qos): QoS used when publishing the Will message.\npayload (String): Content of Will message.\nretain (Bool): Whether the Will message is to be retained when it is published.\n\n\n\n\n\n","category":"type"},{"location":"#AWSCRT._do_local_shadow_update!-Tuple{ShadowFramework, Dict{String}}","page":"Home","title":"AWSCRT._do_local_shadow_update!","text":"_do_local_shadow_update!(sf::ShadowFramework, state::Dict{String,<:Any})\n\nFires the pre-update callback\nUpdates each shadow property from state and fires its callback if an update occured\nFires the post-update callback\nReturns true if any updated occured.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT._sync_version!-Tuple{AbstractDict, String}","page":"Home","title":"AWSCRT._sync_version!","text":"_sync_version!(doc::AbstractDict, payload_str::String)\n\nUpdates the local shadow's version number using the version in the payload.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT._update_local_shadow_from_delta!-Tuple{ShadowFramework, String}","page":"Home","title":"AWSCRT._update_local_shadow_from_delta!","text":"_update_local_shadow_from_delta!(sf::ShadowFramework, payload_str::String)\n\nPerforms a local shadow update using the delta state from an /update/delta document. Returns true if the local shadow was updated.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT._update_local_shadow_from_get!-Tuple{ShadowFramework, String}","page":"Home","title":"AWSCRT._update_local_shadow_from_get!","text":"_update_local_shadow_from_get!(sf::ShadowFramework, payload_str::String)\n\nPerforms a local shadow update using the delta state from a /get/accepted document. Returns true if the local shadow was updated.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT._update_shadow_property!-Tuple{ShadowFramework, AbstractDict, String, Any}","page":"Home","title":"AWSCRT._update_shadow_property!","text":"_update_shadow_property!(sf::ShadowFramework, doc::AbstractDict, key::String, value)\n\nUpdates the shadow property if the new value is not equal to the current value at the key. If the value is an AbstractDict, it is merged into the doc instead of overwriting the key. Returns true if an update occured.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.connect-Tuple{MQTTConnection, String, Integer, String}","page":"Home","title":"AWSCRT.connect","text":"connect(\n    connection::MQTTConnection,\n    server_name::String,\n    port::Integer,\n    client_id::String;\n    clean_session::Bool = true,\n    on_connection_interrupted::Union{OnConnectionInterrupted,Nothing} = nothing,\n    on_connection_resumed::Union{OnConnectionResumed,Nothing} = nothing,\n    reconnect_min_timeout_secs::Integer = 5,\n    reconnect_max_timeout_secs::Integer = 60,\n    keep_alive_secs::Integer = 1200,\n    ping_timeout_ms::Integer = 3000,\n    protocol_operation_timeout_ms::Integer = 0,\n    will::Union{Will,Nothing} = nothing,\n    username::Union{String,Nothing} = nothing,\n    password::Union{String,Nothing} = nothing,\n    socket_options = Ref(aws_socket_options(AWS_SOCKET_STREAM, AWS_SOCKET_IPV6, 5000, 0, 0, 0, false)),\n    alpn_list::Union{Vector{String},Nothing} = nothing,\n    use_websockets::Bool = false,\n    websocket_handshake_transform = nothing, # TODO union type\n    proxy_options = nothing, # TODO union type\n)\n\nOpen the actual connection to the server (async).\n\nArguments:\n\nconnection (MQTTConnection): Connection to use.\nserver_name (String): Server name to connect to.\nport (Integer): Server port to connect to.\nclient_id (String): ID to place in CONNECT packet. Must be unique across all devices/clients. If an ID is already in use, the other client will be disconnected.\nclean_session (Bool) (default=true): Whether or not to start a clean session with each reconnect. If true, the server will forget all subscriptions with each reconnect. Set false to request that the server resume an existing session or start a new session that may be resumed after a connection loss. The session_present bool in the connection callback informs whether an existing session was successfully resumed. If an existing session is resumed, the server remembers previous subscriptions and sends mesages (with QoS level 1 or higher) that were published while the client was offline.\non_connection_interrupted (Union{OnConnectionInterrupted,Nothing}) (default=nothing): Optional callback invoked whenever the MQTT connection is lost. The MQTT client will automatically attempt to reconnect. See OnConnectionInterrupted.\non_connection_resumed (Union{OnConnectionResumed,Nothing}) (default=nothing): Optional callback invoked whenever the MQTT connection is automatically resumed. See OnConnectionResumed.\nreconnect_min_timeout_secs (Integer) (default=5): Minimum time to wait between reconnect attempts. Must be <= reconnect_max_timeout_secs. Wait starts at min and doubles with each attempt until max is reached.\nreconnect_max_timeout_secs (Integer) (default=60): Maximum time to wait between reconnect attempts. Must be >= reconnect_min_timeout_secs. Wait starts at min and doubles with each attempt until max is reached.\nkeep_alive_secs (Integer) (default=1200): The keep alive value (seconds) to send in CONNECT packet. A PING will automatically be sent at this interval. The server will assume the connection is lost if no PING is received after 1.5X this value. This duration must be longer than ping_timeout_ms.\nping_timeout_ms (Integer) (default=3000): Milliseconds to wait for ping response before client assumes the connection is invalid and attempts to reconnect. This duration must be shorter than keep_alive_secs.\nprotocol_operation_timeout_ms (Integer) (default=0): Milliseconds to wait for a response to an operation that requires a response by the server. Set to zero to disable timeout. Otherwise, the operation will fail if no response is received within this amount of time after the packet is written to the socket. This works with PUBLISH (if QoS level > 0) and UNSUBSCRIBE.\nwill (Union{Will,Nothing}) (default=nothing): Will to send with CONNECT packet. The will is published by the server when its connection to the client is unexpectedly lost.\nusername (Union{String,Nothing}) (default=nothing): Username to connect with.\npassword (Union{String,Nothing}) (default=nothing): Password to connect with.\nsocket_options (Ref(aws_socket_options}) (default=Ref(aws_socket_options(AWS_SOCKET_STREAM, AWS_SOCKET_IPV6, 5000, 0, 0, 0, false))): Optional socket options.\nalpn_list (Union{Vector{String},Nothing}) (default=nothing): Connection-specific Application Layer Protocol Negotiation (ALPN) list. This overrides any ALPN list on the TLS context in the client this connection was made with. ALPN is not supported on all systems, see aws_tls_is_alpn_available.\nuse_websockets (Bool) (default=false): # TODO not implemented\nwebsocket_handshake_transform (nothing) (default=nothing): # TODO not implemented\nproxy_options (nothing) (default=nothing): # TODO not implemented\n\nReturns a task which completes when the connection succeeds or fails.\n\nIf the connection succeeds, the task will contain a dict containing the following keys:\n\n:session_present: true if resuming an existing session, false if new session\n\nIf the connection fails, the task will throw an exception.\n\nnote: Note\nAll callbacks are run concurrently. Your callback implementations must be thread-safe. There is no concurrency limit.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.create_client_with_mtls-Tuple{Any, Any}","page":"Home","title":"AWSCRT.create_client_with_mtls","text":"create_client_with_mtls(cert_data, pk_data; kwargs...)\n\nCreate options configured for use with mutual TLS in client mode. Both buffers are treated as PKCS #7 PEM armored.\n\nArguments:\n\ncert_data (String): Certificate contents\npk_data (String): Private key contents.\nca_dirpath (Union{String,Nothing}) (default=nothing): Path to directory containing trusted certificates, which will overrides the default trust store. Only supported on Unix.\nca_filepath (Union{String,Nothing}) (default=nothing): Path to file containing PEM armored chain of trusted CA certificates.\nca_data (Union{String,Nothing}) (default=nothing): PEM armored chain of trusted CA certificates.\nalpn_list (Union{Vector{String},Nothing}) (default=nothing): If set, names to use in Application Layer Protocol Negotiation (ALPN). ALPN is not supported on all systems, see aws_tls_is_alpn_available. This can be customized per connection; see TLSConnectionOptions.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.create_client_with_mtls_from_path-Tuple{Any, Any}","page":"Home","title":"AWSCRT.create_client_with_mtls_from_path","text":"create_client_with_mtls_from_path(cert_filepath, pk_filepath; kwargs...)\n\nCreate options configured for use with mutual TLS in client mode. Both files are treated as PKCS #7 PEM armored. They are loaded from disk and stored in buffers internally.\n\nArguments:\n\ncert_filepath (String): Path to certificate file.\npk_filepath (String): Path to private key file.\nca_dirpath (Union{String,Nothing}) (default=nothing): Path to directory containing trusted certificates, which will overrides the default trust store. Only supported on Unix.\nca_filepath (Union{String,Nothing}) (default=nothing): Path to file containing PEM armored chain of trusted CA certificates.\nca_data (Union{String,Nothing}) (default=nothing): PEM armored chain of trusted CA certificates.\nalpn_list (Union{Vector{String},Nothing}) (default=nothing): If set, names to use in Application Layer Protocol Negotiation (ALPN). ALPN is not supported on all systems, see aws_tls_is_alpn_available. This can be customized per connection; see TLSConnectionOptions.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.create_server-Tuple{Any, Any}","page":"Home","title":"AWSCRT.create_server","text":"create_server(cert_data, pk_data; kwargs...)\n\nCreate options configured for use in server mode. Both buffers are treated as PKCS #7 PEM armored.\n\nArguments:\n\ncert_data (String): Certificate contents\npk_data (String): Private key contents.\nca_dirpath (Union{String,Nothing}) (default=nothing): Path to directory containing trusted certificates, which will overrides the default trust store. Only supported on Unix.\nca_filepath (Union{String,Nothing}) (default=nothing): Path to file containing PEM armored chain of trusted CA certificates.\nca_data (Union{String,Nothing}) (default=nothing): PEM armored chain of trusted CA certificates.\nalpn_list (Union{Vector{String},Nothing}) (default=nothing): If set, names to use in Application Layer Protocol Negotiation (ALPN). ALPN is not supported on all systems, see aws_tls_is_alpn_available. This can be customized per connection; see TLSConnectionOptions.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.create_server_from_path-Tuple{Any, Any}","page":"Home","title":"AWSCRT.create_server_from_path","text":"create_server_from_path(cert_filepath, pk_filepath; kwargs...)\n\nCreate options configured for use in server mode. Both files are treated as PKCS #7 PEM armored. They are loaded from disk and stored in buffers internally.\n\nArguments:\n\ncert_filepath (String): Path to certificate file.\npk_filepath (String): Path to private key file.\nca_dirpath (Union{String,Nothing}) (default=nothing): Path to directory containing trusted certificates, which will overrides the default trust store. Only supported on Unix.\nca_filepath (Union{String,Nothing}) (default=nothing): Path to file containing PEM armored chain of trusted CA certificates.\nca_data (Union{String,Nothing}) (default=nothing): PEM armored chain of trusted CA certificates.\nalpn_list (Union{Vector{String},Nothing}) (default=nothing): If set, names to use in Application Layer Protocol Negotiation (ALPN). ALPN is not supported on all systems, see aws_tls_is_alpn_available. This can be customized per connection; see TLSConnectionOptions.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.disconnect-Tuple{MQTTConnection}","page":"Home","title":"AWSCRT.disconnect","text":"disconnect(connection::MQTTConnection)\n\nClose the connection to the server (async). Returns a task which completes when the connection is closed. If there is no MQTT connection or network connection, the task completes. The task will contain nothing.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.on_message-Tuple{MQTTConnection, Union{Nothing, Function}}","page":"Home","title":"AWSCRT.on_message","text":"on_message(connection::MQTTConnection, callback::Union{OnMessage,Nothing})\n\nSet callback to be invoked when ANY message is received.\n\nArguments:\n\nconnection (MQTTConnection): Connection to use.\ncallback (Union{OnMessage,Nothing}): Optional callback invoked when message received. See OnMessage for the required signature. Set to nothing to clear this callback.\n\nReturns nothing.\n\nnote: Note\nAll callbacks are run concurrently. Your callback implementations must be thread-safe. There is no concurrency limit.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.publish","page":"Home","title":"AWSCRT.publish","text":"publish(connection::MQTTConnection, topic::String, payload::String, qos::aws_mqtt_qos, retain::Bool = false)\n\nPublish message (async). If the device is offline, the PUBLISH packet will be sent once the connection resumes.\n\nArguments:\n\nconnection (MQTTConnection): Connection to use.\ntopic (String): Topic name.\npayload (String): Contents of message.\nqos (aws_mqtt_qos): Maximum requested QoS that the server may use when sending messages to the client. The server may grant a lower QoS in the SUBACK (see returned task).\nretain (Bool): If true, the server will store the message and its QoS so that it can be delivered to future subscribers whose subscriptions match its topic name.\n\nReturns a task and the ID of the PUBLISH packet. The QoS determines when the task completes:\n\nFor QoS 0, completes as soon as the packet is sent.\nFor QoS 1, completes when PUBACK is received.\nFor QoS 2, completes when PUBCOMP is received.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the PUBLISH packet that is complete.\n\nIf unsuccessful, the task will throw an exception.\n\nIf there is no MQTT connection or network connection, the task may wait forever.\n\nThrows if the PUBLISH packet could not be sent.\n\n\n\n\n\n","category":"function"},{"location":"#AWSCRT.publish-Tuple{ShadowClient, String, String, LibAwsMqtt.aws_mqtt_qos}","page":"Home","title":"AWSCRT.publish","text":"publish(client::ShadowClient, topic::String, payload::String, qos::aws_mqtt_qos)\n\nPublishes the payload to the topic under the configured shadow topic.\n\nArguments:\n\nclient (ShadowClient): Shadow client to use.\ntopic (String): Topic name, not including the shadow topic prefix. E.g. /get.\npayload (String): Message contents.\nqos (aws_mqtt_qos): Maximum requested QoS that the server may use when sending messages to the client. The server may grant a lower QoS in the SUBACK (see returned task).\n\nReturns a task and the ID of the PUBLISH packet. The QoS determines when the task completes:\n\nFor QoS 0, completes as soon as the packet is sent.\nFor QoS 1, completes when PUBACK is received.\nFor QoS 2, completes when PUBCOMP is received.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the PUBLISH packet that is complete.\n\nIf unsuccessful, the task will throw an exception.\n\nIf there is no MQTT connection or network connection, the task may wait forever.\n\nThrows if the PUBLISH packet could not be sent.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.publish_current_state-Tuple{ShadowFramework}","page":"Home","title":"AWSCRT.publish_current_state","text":"publish_current_state(sf::ShadowFramework; include_version::Bool = true)\n\nPublishes the current state of the shadow document.\n\nArguments:\n\ninclude_version (Bool): Includes the version of the shadow document if this is true. You may want to exclude the version if you don't know what the broker's version is.\n\nReturns a task and the ID of the PUBLISH packet. The QoS determines when the task completes:\n\nFor QoS 0, completes as soon as the packet is sent.\nFor QoS 1, completes when PUBACK is received.\nFor QoS 2, completes when PUBCOMP is received.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the PUBLISH packet that is complete.\n\nIf unsuccessful, the task will throw an exception.\n\nIf there is no MQTT connection or network connection, the task may wait forever.\n\nThrows if the PUBLISH packet could not be sent.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.resubscribe_existing_topics-Tuple{MQTTConnection}","page":"Home","title":"AWSCRT.resubscribe_existing_topics","text":"resubscribe_existing_topics(connection::MQTTConnection)\n\nSubscribe again to all current topics. This is to help when resuming a connection with a clean session.\n\nReturns a task and the ID of the SUBSCRIBE packet. The task completes when a SUBACK is received from the server.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the SUBSCRIBE packet being acknowledged.\n:topics (Vector{Tuple{Union{String,Nothing},aws_mqtt_qos}}): Topic filter of the SUBSCRIBE packet being acknowledged and its QoS level. The topic will be nothing if the topic failed to resubscribe. The vector will be empty if there were no topics to resubscribe.\n\nIf unsuccessful, the task contains an exception.\n\nThrows if the SUBSCRIBE packet could not be sent.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.shadow_client-Tuple{ShadowFramework}","page":"Home","title":"AWSCRT.shadow_client","text":"shadow_client(sf::ShadowFramework)\n\nReturns the ShadowClient for sf.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.subscribe-Tuple{MQTTConnection, String, LibAwsMqtt.aws_mqtt_qos, Function}","page":"Home","title":"AWSCRT.subscribe","text":"subscribe(connection::MQTTConnection, topic::String, qos::aws_mqtt_qos, callback::OnMessage)\n\nSubsribe to a topic filter (async). The client sends a SUBSCRIBE packet and the server responds with a SUBACK. This function may be called while the device is offline, though the async operation cannot complete successfully until the connection resumes. Once subscribed, callback is invoked each time a message matching the topic is received. It is possible for such messages to arrive before the SUBACK is received.\n\nArguments:\n\nconnection (MQTTConnection): Connection to use.\ntopic (String): Subscribe to this topic filter, which may include wildcards.\nqos (aws_mqtt_qos): Maximum requested QoS that the server may use when sending messages to the client. The server may grant a lower QoS in the SUBACK (see returned task).\ncallback (OnMessage): Callback invoked when a message is received. See OnMessage for the required signature.\n\nReturns a task and the ID of the SUBSCRIBE packet. The task completes when a SUBACK is received from the server.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the SUBSCRIBE packet being acknowledged.\n:topic (String): Topic filter of the SUBSCRIBE packet being acknowledged.\n:qos (aws_mqtt_qos): Maximum QoS that was granted by the server. This may be lower than the requested QoS.\n\nIf unsuccessful, the task contains an exception.\n\nIf there is no MQTT connection or network connection, the task may wait forever.\n\nThrows if the SUBSCRIBE packet could not be sent.\n\nnote: Note\nAll callbacks are run concurrently. Your callback implementations must be thread-safe. There is no concurrency limit.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.subscribe-Tuple{ShadowClient, LibAwsMqtt.aws_mqtt_qos, Function}","page":"Home","title":"AWSCRT.subscribe","text":"subscribe(client::ShadowClient, qos::aws_mqtt_qos, callback::OnShadowMessage)\n\nSubscribes to all topics under the given shadow document using a wildcard, including but not limited to:\n\n/get/accepted\n/get/rejected\n/update/delta\n/update/accepted\n/update/documents\n/update/rejected\n/delete/accepted\n/delete/rejected\n\nArguments:\n\nclient (ShadowClient): Shadow client to use.\nqos (aws_mqtt_qos): Maximum requested QoS that the server may use when sending messages to the client. The server may grant a lower QoS in the SUBACK (see returned task).\ncallback (OnShadowMessage): Callback invoked when message received. See OnShadowMessage for the required signature.\n\nReturns a task which completes when the tasks from each subscribe call complete. Also returns a collection containing the packet ID from each subscribe call.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.subscribe-Tuple{ShadowClient, String, LibAwsMqtt.aws_mqtt_qos, Function}","page":"Home","title":"AWSCRT.subscribe","text":"subscribe(client::ShadowClient, topic::String, qos::aws_mqtt_qos, callback::OnMessage)\n\nSubscribes to the given topic (must contain a leading forward slash (/)) under the given shadow document.\n\nArguments:\n\nclient (ShadowClient): Shadow client to use.\ntopic (String): Subscribe to this topic filter, which may include wildcards, under the given shadow document.\nqos (aws_mqtt_qos): Maximum requested QoS that the server may use when sending messages to the client. The server may grant a lower QoS in the SUBACK (see returned task).\ncallback (OnMessage): Callback invoked when a message is received. See OnMessage for the required signature.\n\nReturns a task and the ID of the SUBSCRIBE packet. The task completes when a SUBACK is received from the server.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the SUBSCRIBE packet being acknowledged.\n:topic (String): Topic filter of the SUBSCRIBE packet being acknowledged.\n:qos (aws_mqtt_qos): Maximum QoS that was granted by the server. This may be lower than the requested QoS.\n\nIf unsuccessful, the task contains an exception.\n\nIf there is no MQTT connection or network connection, the task may wait forever.\n\nThrows if the SUBSCRIBE packet could not be sent.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.subscribe-Tuple{ShadowFramework}","page":"Home","title":"AWSCRT.subscribe","text":"subscribe(sf::ShadowFramework)\n\nSubscribes to the shadow document's topics and begins processing updates. The sf is always locked before reading/writing from/to the shadow document. If the remote shadow document does not exist, the local shadow document will be used to create it.\n\nPublishes an initial message to the /get topic to synchronize the shadow document with the broker's state. You can call wait_until_synced(sf) if you need to wait until this synchronization is done.\n\nReturns a task and the ID of the PUBLISH packet. The QoS determines when the task completes:\n\nFor QoS 0, completes as soon as the packet is sent.\nFor QoS 1, completes when PUBACK is received.\nFor QoS 2, completes when PUBCOMP is received.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the PUBLISH packet that is complete.\n\nIf unsuccessful, the task will throw an exception.\n\nIf there is no MQTT connection or network connection, the task may wait forever.\n\nThrows if the PUBLISH packet could not be sent.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.unsubscribe-Tuple{MQTTConnection, String}","page":"Home","title":"AWSCRT.unsubscribe","text":"unsubscribe(connection::MQTTConnection, topic::String)\n\nUnsubscribe from a topic filter (async). The client sends an UNSUBSCRIBE packet, and the server responds with an UNSUBACK.\n\nArguments:\n\nconnection (MQTTConnection): Connection to use.\ntopic (String): Unsubscribe from this topic filter.\n\nReturns a task and the ID of the UNSUBSCRIBE packet. The task completes when an UNSUBACK is received from the server.\n\nIf successful, the task will contain a dict with the following members:\n\n:packet_id (Int): ID of the UNSUBSCRIBE packet being acknowledged.\n\nIf unsuccessful, the task will throw an exception.\n\nIf there is no MQTT connection or network connection, the task may wait forever.\n\nThrows if the UNSUBSCRIBE packet could not be sent.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.unsubscribe-Tuple{ShadowClient}","page":"Home","title":"AWSCRT.unsubscribe","text":"unsubscribe(client::ShadowClient)\n\nUnsubscribes from all shadow document topics.\n\nArguments:\n\nclient (ShadowClient): Shadow client to use.\n\nReturns a task which completes when the tasks from each unsubscribe call complete. Also returns a collection containing the packet ID from each unsubscribe call.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.unsubscribe-Tuple{ShadowFramework}","page":"Home","title":"AWSCRT.unsubscribe","text":"unsubscribe(sf::ShadowFramework)\n\nUnsubscribes from the shadow document's topics and stops processing updates. After calling this, wait_until_synced(sf) will again block until the first publish in response to calling subscribe(sf).\n\nReturns a task which completes when the tasks from each unsubscribe call complete. Also returns a collection containing the packet ID from each unsubscribe call.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.wait_until_synced-Tuple{Function, ShadowFramework}","page":"Home","title":"AWSCRT.wait_until_synced","text":"wait_until_synced(f::Function, sf::ShadowFramework)\n\nBlocks until the next time the shadow document is synchronized with the broker. If you want to wait for a synchronization after a publication that you make, then you must make that publication inside the lambda f.\n\n\n\n\n\n","category":"method"},{"location":"#AWSCRT.wait_until_synced-Tuple{ShadowFramework}","page":"Home","title":"AWSCRT.wait_until_synced","text":"wait_until_synced(sf::ShadowFramework)\n\nBlocks until the next time the shadow document is synchronized with the broker.\n\n!!! warning \"Warning: Race Condition\"\n    If you are using this function to publish a message and then wait for the following synchronization, you\n    must use the `do` form of [`wait_until_synced`](@ref) instead which accepts a lambda as the first argument.\n    Otherwise, your publish will race the synchronization and there is a chance the synchronization will finish before\n    you begin waiting for it (so you miss the edge and your program hangs).\n\n\n\n\n\n","category":"method"},{"location":"#Base.lock-Tuple{Function, ShadowFramework}","page":"Home","title":"Base.lock","text":"lock(f::Function, sf::ShadowFramework)\n\nLocks the sf to ensure atomic access to the shadow document.\n\n\n\n\n\n","category":"method"},{"location":"#Base.lock-Tuple{ShadowFramework}","page":"Home","title":"Base.lock","text":"lock(sf::ShadowFramework)\n\nLocks the sf to ensure atomic access to the shadow document.\n\n\n\n\n\n","category":"method"},{"location":"#Base.unlock-Tuple{ShadowFramework}","page":"Home","title":"Base.unlock","text":"unlock(sf::ShadowFramework)\n\nUnlocks the sf.\n\n\n\n\n\n","category":"method"}]
}
